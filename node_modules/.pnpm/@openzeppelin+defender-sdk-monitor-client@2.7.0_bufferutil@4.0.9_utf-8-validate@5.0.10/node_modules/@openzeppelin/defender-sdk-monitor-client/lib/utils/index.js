"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseAbi = exports.getAbiInterface = exports.getMonitorConditions = exports.toConditionField = void 0;
const lodash_1 = require("lodash");
const ethers_1 = require("ethers");
const ethers_2 = require("../models/ethers");
// converts to payload for save API
function getConditionSets(txExpression, eventConditions, functionConditions) {
    const txConds = txExpression ? [{ status: 'any', expression: txExpression }] : [];
    const evtConds = (0, lodash_1.compact)(eventConditions.map((ec) => {
        return ec.selected
            ? {
                eventSignature: ec.signature,
                expression: ec.expression,
            }
            : undefined;
    }));
    const funcConds = (0, lodash_1.compact)(functionConditions.map((fc) => {
        return fc.selected
            ? {
                functionSignature: fc.signature,
                expression: fc.expression,
            }
            : undefined;
    }));
    // if no conditions, just return empty list
    if (txConds.length == 0 && evtConds.length == 0 && funcConds.length == 0) {
        return [];
    }
    // if only txcondition exists, then return a standalone condition for that
    if (evtConds.length == 0 && funcConds.length == 0) {
        return [
            {
                txConditions: txConds,
                eventConditions: [],
                functionConditions: [],
            },
        ];
    }
    const result = [];
    for (const c of evtConds) {
        result.push({
            txConditions: txConds,
            eventConditions: [c],
            functionConditions: [],
        });
    }
    for (const c of funcConds) {
        result.push({
            txConditions: txConds,
            eventConditions: [],
            functionConditions: [c],
        });
    }
    return result;
}
exports.default = getConditionSets;
function toConditionField(description, condition) {
    const field = {
        description,
        signature: description.format(),
        inputs: description.inputs.map((i) => i.name).filter(Boolean),
        selected: false,
        expression: '',
    };
    if (condition) {
        field.selected = true;
        field.expression = condition.expression || '';
    }
    return field;
}
exports.toConditionField = toConditionField;
const bySignature = (e) => e.format();
function getMonitorConditions(addressRules) {
    let txExpression = '';
    let eventConditions = [];
    let functionConditions = [];
    let abiEvents = [];
    let abiFunctions = [];
    for (const rule of addressRules) {
        const abiInterface = getAbiInterface(rule.abi);
        if (abiInterface) {
            const events = [];
            const functions = [];
            abiInterface.forEachEvent((e) => events.push(e));
            abiInterface.forEachFunction((f) => ((0, ethers_2.isTransactionMethod)(f) ? functions.push(f) : null));
            if (events.length)
                abiEvents.push(...events);
            if (functions.length)
                abiFunctions.push(...functions);
        }
        for (const condition of rule.conditions) {
            for (const cond of condition.txConditions) {
                if (cond.expression)
                    txExpression = cond.expression;
            }
            eventConditions = eventConditions.concat(condition.eventConditions);
            functionConditions = functionConditions.concat(condition.functionConditions);
        }
    }
    abiEvents = (0, lodash_1.sortBy)(abiEvents, bySignature);
    abiFunctions = (0, lodash_1.sortBy)(abiFunctions, bySignature);
    return {
        txExpression,
        events: abiEvents.map((event) => toConditionField(event, eventConditions.find((cond) => event.format() == cond.eventSignature))),
        functions: abiFunctions.map((func) => toConditionField(func, functionConditions.find((cond) => func.format() == cond.functionSignature))),
    };
}
exports.getMonitorConditions = getMonitorConditions;
function getAbiInterface(abi) {
    if (!abi)
        return;
    try {
        return (0, exports.parseAbi)(abi);
    }
    catch (e) {
        return undefined;
    }
}
exports.getAbiInterface = getAbiInterface;
const parseAbi = (abi) => {
    try {
        return new ethers_1.Interface(abi);
    }
    catch (e) {
        throw new Error('Please enter a valid ABI');
    }
};
exports.parseAbi = parseAbi;
