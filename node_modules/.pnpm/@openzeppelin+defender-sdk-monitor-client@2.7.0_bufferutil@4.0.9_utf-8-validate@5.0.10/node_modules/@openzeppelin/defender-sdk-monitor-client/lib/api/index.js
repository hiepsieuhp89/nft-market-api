"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MonitorClient = void 0;
const defender_sdk_base_client_1 = require("@openzeppelin/defender-sdk-base-client");
const lodash_1 = __importDefault(require("lodash"));
const utils_1 = __importStar(require("../utils"));
class MonitorClient extends defender_sdk_base_client_1.BaseApiClient {
    getPoolId() {
        return process.env.DEFENDER_POOL_ID || 'us-west-2_94f3puJWv';
    }
    getPoolClientId() {
        return process.env.DEFENDER_POOL_CLIENT_ID || '40e58hbc7pktmnp9i26hh5nsav';
    }
    getApiUrl() {
        // TODO: update to /monitor when available
        return process.env.DEFENDER_API_URL || 'https://defender-api.openzeppelin.com/v2/';
    }
    async list() {
        return this.apiCall(async (api) => {
            return await api.get(`/monitors`);
        });
    }
    async create(params) {
        const newMonitor = await this.constructMonitorRequest(params);
        return this.apiCall(async (api) => {
            return await api.post(`/monitors`, newMonitor);
        });
    }
    // TODO: maybe add a named type here
    async get(id) {
        return this.apiCall(async (api) => {
            return await api.get(`/monitors/${id}`);
        });
    }
    async update(id, params) {
        return this.apiCall(async (api) => {
            return await api.put(`/monitors/${id}`, params);
        });
    }
    // TODO: maybe add a named type here
    async delete(id) {
        return this.apiCall(async (api) => {
            return await api.delete(`/monitors/${id}`);
        });
    }
    async pause(id) {
        return this.apiCall(async (api) => {
            return await api.put(`/monitors/${id}`, { paused: true });
        });
    }
    async unpause(id) {
        return this.apiCall(async (api) => {
            return await api.put(`/monitors/${id}`, { paused: false });
        });
    }
    // TODO: should this be  part of public API?
    async listBlockwatchers() {
        return this.apiCall(async (api) => {
            return await api.get(`/blockwatchers`);
        });
    }
    async listTenantBlockwatchers() {
        return this.apiCall(async (api) => {
            return await api.get(`/blockwatchers/tenant`);
        });
    }
    async createNotificationChannel(notification) {
        return this.apiCall(async (api) => {
            return await api.post(`/notifications/${notification.type}`, notification);
        });
    }
    async listNotificationChannels() {
        return this.apiCall(async (api) => {
            return await api.get(`/notifications`);
        });
    }
    async deleteNotificationChannel(id, type) {
        return this.apiCall(async (api) => {
            return await api.delete(`/notifications/${type}/${id}`);
        });
    }
    async getNotificationChannel(id, type) {
        return this.apiCall(async (api) => {
            return await api.get(`/notifications/${type}/${id}`);
        });
    }
    async updateNotificationChannel(id, notification) {
        return this.apiCall(async (api) => {
            return await api.put(`/notifications/${notification.type}/${id}`, notification);
        });
    }
    async getBlockwatcherIdByNetwork(network) {
        return (await this.listBlockwatchers()).filter((blockwatcher) => blockwatcher.network === network);
    }
    normaliseABI(abi) {
        return abi ? (typeof abi === 'string' ? abi : JSON.stringify(abi)) : undefined;
    }
    async constructBlockMonitor(monitor) {
        let blockWatchers = [];
        if (!(0, defender_sdk_base_client_1.isValidNetwork)(monitor.network)) {
            blockWatchers = (await this.listTenantBlockwatchers()).filter((blockwatcher) => blockwatcher.network === monitor.network);
        }
        else {
            blockWatchers = await this.getBlockwatcherIdByNetwork(monitor.network);
        }
        let blockWatcherId;
        if (blockWatchers?.length > 0) {
            const blockWatchersSorted = lodash_1.default.sortBy(blockWatchers.filter(({ confirmLevel }) => lodash_1.default.isNumber(confirmLevel)), // Only consider numberish confirmLevels
            ['confirmLevel']).reverse();
            blockWatcherId = blockWatchersSorted[0]?.blockWatcherId;
        }
        if (monitor.confirmLevel) {
            blockWatcherId = blockWatchers.find((watcher) => watcher.confirmLevel === monitor.confirmLevel)?.blockWatcherId;
        }
        if (!blockWatcherId) {
            throw new Error(`Provided network and confirmLevel do not match a block watcher.`);
        }
        const newConditions = [];
        if (monitor.eventConditions) {
            monitor.eventConditions.map((condition) => {
                newConditions.push({
                    eventConditions: [condition],
                    txConditions: [],
                    functionConditions: [],
                });
            });
        }
        if (monitor.functionConditions) {
            monitor.functionConditions.map((condition) => {
                newConditions.push({
                    eventConditions: [],
                    txConditions: [],
                    functionConditions: [condition],
                });
            });
        }
        if (monitor.txCondition) {
            newConditions.push({
                eventConditions: [],
                txConditions: [{ status: 'any', expression: monitor.txCondition }],
                functionConditions: [],
            });
        }
        const conditions = (0, utils_1.getMonitorConditions)([
            {
                conditions: newConditions,
                abi: this.normaliseABI(monitor.abi),
                addresses: monitor.addresses,
            },
        ]);
        return {
            blockWatcherId,
            addressRules: [
                {
                    conditions: (0, utils_1.default)(conditions.txExpression, conditions.events, conditions.functions),
                    actionCondition: monitor.actionCondition ? { actionId: monitor.actionCondition } : undefined,
                    addresses: monitor.addresses,
                    abi: this.normaliseABI(monitor.abi),
                },
            ],
            network: monitor.network,
            type: 'BLOCK',
            skipABIValidation: monitor.skipABIValidation,
        };
    }
    async getNotifications(monitorChannels) {
        const notifications = [];
        const notificationChannels = await this.listNotificationChannels();
        notificationChannels.map((channel) => {
            if (monitorChannels.includes(channel.notificationId)) {
                notifications.push(channel);
            }
        });
        return notifications;
    }
    async constructMonitorRequest(monitor) {
        let partialResponse;
        if (monitor.type === 'BLOCK') {
            partialResponse = await this.constructBlockMonitor(monitor);
        }
        else {
            throw new Error(`Invalid monitor type. Type must be BLOCK`);
        }
        const notificationChannels = await this.getNotifications(monitor.notificationChannels);
        return {
            ...partialResponse,
            name: monitor.name,
            alertThreshold: monitor.alertThreshold,
            notifyConfig: {
                notifications: notificationChannels,
                severityLevel: monitor.severityLevel,
                actionId: monitor.actionTrigger ? monitor.actionTrigger : undefined,
                timeoutMs: monitor.alertTimeoutMs ? monitor.alertTimeoutMs : 0,
                messageBody: monitor.alertMessageBody ? monitor.alertMessageBody : undefined,
                messageSubject: monitor.alertMessageSubject ? monitor.alertMessageSubject : undefined,
            },
            paused: monitor.paused ? monitor.paused : false,
            riskCategory: monitor.riskCategory,
            stackResourceId: monitor.stackResourceId,
        };
    }
    toCreateBlockMonitorRequest(monitor) {
        const rule = monitor.addressRules[0];
        if (!rule)
            throw new Error(`No rule found for monitor ${monitor.name}`);
        let txCondition;
        for (const condition of rule.conditions) {
            for (const cond of condition.txConditions) {
                if (cond.expression)
                    txCondition = cond.expression;
            }
        }
        return {
            type: 'BLOCK',
            addresses: rule.addresses,
            abi: this.normaliseABI(rule.abi),
            eventConditions: lodash_1.default.flatten(rule.conditions.map((condition) => condition.eventConditions)),
            functionConditions: lodash_1.default.flatten(rule.conditions.map((condition) => condition.functionConditions)),
            txCondition,
            name: monitor.name,
            paused: monitor.paused,
            skipABIValidation: monitor.skipABIValidation,
            alertThreshold: monitor.alertThreshold,
            actionCondition: rule.actionCondition?.actionId,
            actionTrigger: monitor.notifyConfig?.actionId,
            alertTimeoutMs: monitor.notifyConfig?.timeoutMs,
            alertMessageSubject: monitor.notifyConfig?.messageSubject,
            alertMessageBody: monitor.notifyConfig?.messageBody,
            notificationChannels: monitor.notifyConfig?.notifications?.map(({ notificationId }) => notificationId) ?? [],
            severityLevel: monitor.notifyConfig?.severityLevel,
            network: monitor.network,
            confirmLevel: parseInt(lodash_1.default.last(monitor.blockWatcherId.split('-'))), // We're sure there is always a last number if the convention is followd
        };
    }
    toCreateMonitorRequest(monitor) {
        if (monitor.type === 'BLOCK')
            return this.toCreateBlockMonitorRequest(monitor);
        throw new Error(`Invalid monitor type. Type must be BLOCK`);
    }
}
exports.MonitorClient = MonitorClient;
