"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.initClient = exports.tailLogsFor = exports.validatePath = exports.validateId = void 0;
const fs_1 = require("fs");
const api_1 = require("./api");
/**
 * Regex Validator for Action and Action run IDs.
 */
function validateId(id) {
    const regex = /^[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}$/i;
    if (regex.test(id)) {
        return;
    }
    else {
        throw new Error(`invalid id '${id}'`);
    }
}
exports.validateId = validateId;
/**
 * Checks if path exists, otherwise throws an error.
 */
function validatePath(path) {
    if ((0, fs_1.existsSync)(path)) {
        return;
    }
    else {
        throw new Error(`path ${path} does not exist`);
    }
}
exports.validatePath = validatePath;
async function tailLogsFor(client, actionId) {
    try {
        validateId(actionId);
        console.warn(`\nPolling latest runs of action '${actionId}'...\n`);
        // Poll action runs every 2 seconds and if there are new runs, get run details and print them out.
        let lastRun;
        while (true) {
            const newRuns = await client.listActionRuns(actionId, {});
            // If cached last run id has changed
            if (newRuns.items[0]?.actionRunId !== lastRun?.actionRunId) {
                lastRun = newRuns.items[0]; // cache new last run to avoid duplicates.
                if (!lastRun)
                    throw new Error('last run not found');
                const status = lastRun.status;
                if (status === 'pending') {
                    lastRun = undefined; // clean up so we can check it again on the next poll.
                }
                else if (status === 'error') {
                    const runDetails = (await client.getActionRun(lastRun.actionRunId));
                    console.log(`\nError: ${runDetails.message}`);
                    runDetails.decodedLogs ? console.log(`\n${runDetails.decodedLogs}`) : console.log(`No logs available.`);
                }
                else if (status === 'success') {
                    const runDetails = (await client.getActionRun(lastRun.actionRunId));
                    console.log(`\n${runDetails.decodedLogs}`);
                }
                else if (status === 'throttled') {
                    console.warn(`\nThis action run was canceled since the hourly run capacity for your account has been exceeded. Contact us at defender-support@openzeppelin.com for additional capacity.`);
                }
            }
            await new Promise((resolve) => setTimeout(resolve, 2000));
        }
    }
    catch (e) {
        throw e;
    }
}
exports.tailLogsFor = tailLogsFor;
/**
 * Verifies that the environment variables are present and initializes the client.
 * @returns The initialized client instance.
 */
function initClient() {
    const { API_KEY: apiKey, API_SECRET: apiSecret } = process.env;
    if (!apiKey || !apiSecret)
        throw new Error(`API_KEY or API_SECRET env vars are missing`);
    const client = new api_1.ActionClient({ apiKey, apiSecret });
    return client;
}
exports.initClient = initClient;
