/// <reference types="node" />
import https from 'https';
import { Network, AuthConfig } from '@openzeppelin/defender-sdk-base-client';
import { ListTransactionsRequest, PaginatedTransactionResponse, PrivateTransactionMode, RelayerTransaction, RelayerTransactionPayload, TransactionDeleteResponse } from './transactions';
import { JsonRpcResponse, SignMessagePayload, SignTypedDataPayload, SignedMessagePayload } from './rpc';
export type Address = string;
export type BigUInt = string | number;
export type RelayerParams = ApiRelayerParams | ActionRelayerParams;
export type ApiRelayerParams = {
    apiKey: string;
    apiSecret: string;
    httpsAgent?: https.Agent;
    authConfig: AuthConfig;
};
export type ActionRelayerParams = {
    credentials: string;
    relayerARN: string;
    httpsAgent?: https.Agent;
    authConfig: AuthConfig;
};
export interface RelayerGetResponse {
    relayerId: string;
    name: string;
    address: string;
    network: Network;
    paused: boolean;
    createdAt: string;
    pendingTxCost: string;
    minBalance: BigUInt;
    policies: UpdateRelayerPoliciesRequest;
    stackResourceId?: string;
}
export interface RelayerStatus {
    relayerId: string;
    name: string;
    nonce: number;
    address: string;
    numberOfPendingTransactions: number;
    paused: boolean;
    pendingTxCost?: string;
    txsQuotaUsage: number;
    rpcQuotaUsage: number;
    lastConfirmedTransaction?: {
        hash: string;
        status: string;
        minedAt: string;
        sentAt: string;
        nonce: number;
    };
}
export interface RelayerGroupStatus {
    relayerGroupId: string;
    name: string;
    numberOfPendingTransactions: number;
    paused: boolean;
    txsQuotaUsage: number;
    rpcQuotaUsage: number;
    healthStatus?: {
        updatedAt?: string;
        weightByRelayer?: {
            [k: string]: number;
        };
    };
    relayers: {
        relayerId: string;
        name: string;
        nonce: number;
        address: string;
        numberOfPendingTransactions: number;
        paused: boolean;
        pendingTxCost?: string;
        lastConfirmedTransaction?: {
            hash: string;
            status: string;
            minedAt: string;
            sentAt: string;
            nonce: number;
        };
    }[];
}
export interface UpdateRelayerPoliciesRequest {
    gasPriceCap?: BigUInt;
    whitelistReceivers?: Address[];
    EIP1559Pricing?: boolean;
    /**
     * Allowing boolean for backwards compatibility.
     * New relayers should use PrivateTransactionMode.
     */
    privateTransactions?: boolean | PrivateTransactionMode;
}
export interface RelayerGroupPolicies {
    gasPriceCap?: BigUInt;
    whitelistReceivers?: Address[];
    EIP1559Pricing?: boolean;
    privateTransactions?: boolean | PrivateTransactionMode;
}
export type RelayerGroupRelayer = {
    relayerId: string;
    address: string;
    keyId: string;
    relayerShortId: string;
    network: Network;
};
export declare enum TxStatus {
    Pending = "pending",
    Sent = "sent",
    Submitted = "submitted",
    InMemPool = "inmempool",
    Mined = "mined",
    Confirmed = "confirmed",
    Failed = "failed",
    Expired = "expired"
}
export interface RelayerGroupResponse {
    relayerGroupId: string;
    name: string;
    network: Network;
    policies: RelayerGroupPolicies;
    minBalance: BigUInt;
    relayers: RelayerGroupRelayer[];
    paused: boolean;
    systemPaused: boolean;
    createdAt: string;
    stackResourceId?: string;
    notificationChannels?: {
        events: TxStatus[];
        notificationIds: string[];
    };
}
export type EthersVersion = 'v5' | 'v6';
export interface IRelayer {
    getRelayer(): Promise<RelayerGetResponse | RelayerGroupResponse>;
    getRelayerStatus(): Promise<RelayerStatus | RelayerGroupStatus>;
    sendTransaction(payload: RelayerTransactionPayload): Promise<RelayerTransaction>;
    replaceTransactionById(id: string, payload: RelayerTransactionPayload): Promise<RelayerTransaction>;
    replaceTransactionByNonce(nonce: number, payload: RelayerTransactionPayload): Promise<RelayerTransaction>;
    cancelTransactionById(id: string): Promise<TransactionDeleteResponse>;
    getTransaction(id: string): Promise<RelayerTransaction>;
    getTransactionByNonce(nonce: number): Promise<RelayerTransaction>;
    listTransactions(criteria?: ListTransactionsRequest): Promise<RelayerTransaction[] | PaginatedTransactionResponse>;
    sign(payload: SignMessagePayload): Promise<SignedMessagePayload>;
    signTypedData(payload: SignTypedDataPayload): Promise<SignedMessagePayload>;
    call(params: {
        method: string;
        params: string[];
    }): Promise<JsonRpcResponse>;
}
//# sourceMappingURL=relayer.d.ts.map