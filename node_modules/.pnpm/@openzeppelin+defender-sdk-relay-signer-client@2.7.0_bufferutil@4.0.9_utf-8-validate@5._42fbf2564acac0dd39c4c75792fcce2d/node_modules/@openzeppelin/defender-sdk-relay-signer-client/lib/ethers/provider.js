"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefenderRelayProvider = void 0;
const signer_1 = require("./signer");
const api_1 = require("../api");
const relayer_1 = require("../relayer");
const ethers_1 = require("ethers");
const utils_1 = require("./utils");
class DefenderRelayProvider extends ethers_1.JsonRpcProvider {
    constructor(credentials) {
        super((0, api_1.getApiUrl)());
        this.credentials = credentials;
        this.pendingNetwork = null;
        this.relayer = new relayer_1.Relayer(credentials);
    }
    async _detectNetwork() {
        this.pendingNetwork = (async () => {
            let result;
            try {
                result = await this.send('eth_chainId', []);
                this.pendingNetwork = null;
            }
            catch (error) {
                this.pendingNetwork = null;
                throw error;
            }
            this.emit('debug', { action: 'receiveRpcResult', result });
            if ((result && typeof result === 'string') || typeof result === 'number') {
                return ethers_1.Network.from((0, ethers_1.getBigInt)(result));
            }
            if (result && 'result' in result) {
                return ethers_1.Network.from((0, ethers_1.getBigInt)(result.result));
            }
            throw this.getRpcError({ id: 1, jsonrpc: '2.0', method: 'eth_chainId', params: [] }, result);
        })();
        return await this.pendingNetwork;
    }
    // Logic from JsonRpcProvider.detectNetwork
    async detectNetwork() {
        return this._detectNetwork();
    }
    async _send(payload) {
        if (Array.isArray(payload)) {
            return Promise.all(payload.map((p) => this.send(p.method, p.params)));
        }
        return [await this.send(payload.method, payload.params)];
    }
    async send(method, params) {
        const request = { method, params };
        this.emit('debug', { action: 'request', request, provider: this });
        try {
            const result = await this.relayer.call(request);
            this.emit('debug', { action: 'response', request, response: result, provider: this });
            if (result.error) {
                const error = new Error(result.error.message);
                error.code = result.error.code;
                error.data = result.error.data;
                throw error;
            }
            return result.result;
        }
        catch (error) {
            this.emit('debug', { action: 'response', error, request: request, provider: this });
            throw error;
        }
    }
    // Logic from JsonRpcProvider.getSigner
    async getSigner(address) {
        if (typeof address === 'number') {
            throw new Error('Invalid address: cannot provide an index number as address, only one relayer address is supported.');
        }
        if (address) {
            return new signer_1.DefenderRelaySigner(this.relayer, this, address, {});
        }
        const relayer = await this.relayer.getRelayer();
        if ((0, utils_1.isRelayerGroup)(relayer)) {
            throw new Error('Relayer Group is not supported.');
        }
        return new signer_1.DefenderRelaySigner(this.relayer, this, relayer.address, {});
    }
}
exports.DefenderRelayProvider = DefenderRelayProvider;
