"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefenderRelaySenderProvider = void 0;
const lodash_1 = require("lodash");
const relayer_1 = require("../relayer");
const utils_1 = require("../ethers/utils");
class DefenderRelaySenderProvider {
    constructor(base, relayerCredentials, options = {}) {
        this.base = base;
        this.options = options;
        this.id = 1;
        this.txHashToId = new Map();
        this._delegateToProvider(base);
        this.relayer = (0, utils_1.isRelayer)(relayerCredentials) ? relayerCredentials : new relayer_1.Relayer(relayerCredentials);
        if (options) {
            const getUnnecesaryExtraFields = (invalidFields) => invalidFields.map((field) => options[field]).filter(Boolean);
            if (options.gasPrice) {
                const unnecesaryExtraFields = getUnnecesaryExtraFields(['maxFeePerGas', 'maxPriorityFeePerGas']);
                if (unnecesaryExtraFields.length > 0)
                    throw new Error(`Inconsistent options: gasPrice + (${unnecesaryExtraFields}) not allowed`);
            }
            else if (options.maxFeePerGas && options.maxPriorityFeePerGas) {
                if (options.maxFeePerGas < options.maxPriorityFeePerGas)
                    throw new Error('Inconsistent options: maxFeePerGas should be greater or equal to maxPriorityFeePerGas');
            }
            else if (options.maxFeePerGas)
                throw new Error('Inconsistent options: maxFeePerGas without maxPriorityFeePerGas specified');
            else if (options.maxPriorityFeePerGas)
                throw new Error('Inconsistent options: maxPriorityFeePerGas without maxFeePerGas specified');
        }
    }
    get connected() {
        return true;
    }
    getTransactionId(hash) {
        return this.txHashToId.get(hash);
    }
    async getAddress() {
        if (!this.address) {
            const relayer = await this.relayer.getRelayer();
            if ((0, utils_1.isRelayerGroup)(relayer)) {
                throw new Error('Relayer Group is not supported.');
            }
            this.address = relayer.address;
        }
        return this.address;
    }
    async request(payload) {
        const id = typeof payload.id === 'string' ? parseInt(payload.id) : payload.id ?? this.id++;
        const toJsonRpcResponse = (result) => ({
            jsonrpc: '2.0',
            id,
            result,
        });
        switch (payload.method) {
            case 'eth_sendTransaction':
                return this._sendTransaction(payload.params ?? []).then(toJsonRpcResponse);
            case 'eth_accounts':
                return this._getAccounts(payload.params ?? []).then(toJsonRpcResponse);
            case 'eth_sign':
                return this._signMessage(payload.params ?? []).then(toJsonRpcResponse);
            case 'eth_signTransaction':
                throw new Error(`Method not supported: eth_signTransaction`);
        }
        return this.base.request(payload);
    }
    async _getAccounts(params) {
        return [await this.getAddress()];
    }
    async _sendTransaction(params) {
        const tx = params[0];
        const relayerAddress = (await this.getAddress()).toLowerCase();
        if (tx.from && tx.from.toLowerCase() !== relayerAddress) {
            throw new Error(`Cannot send transaction from ${tx.from}`);
        }
        const gasLimit = tx.gas ??
            (await this.request
                .bind(this)({
                method: 'eth_estimateGas',
                params: [{ gasLimit: 1e6, ...tx }],
                jsonrpc: '2.0',
                id: 1,
            })
                .then((response) => {
                if (response?.error) {
                    throw new Error(`Error estimating gas for transaction: ${JSON.stringify(response.error)}`);
                }
                return response?.result?.toString();
            }));
        const txWithSpeed = this.options.speed
            ? { ...(0, lodash_1.omit)(tx, 'gasPrice', 'maxFeePerGas', 'maxPriorityFeePerGas'), speed: this.options.speed }
            : tx;
        const payload = { ...this.options, ...txWithSpeed, gasLimit };
        const sent = tx.nonce
            ? await this.relayer.replaceTransactionByNonce(parseInt(tx.nonce), payload)
            : await this.relayer.sendTransaction(payload);
        this.txHashToId.set(sent.hash, sent.transactionId);
        return sent.hash;
    }
    async _signMessage(params) {
        const [from, message] = params;
        if (from.toLowerCase() !== (await this.getAddress()).toLowerCase()) {
            throw new Error(`Cannot sign message as ${from}`);
        }
        return this.relayer.sign({ message }).then((r) => r.sig);
    }
    sendAsync(payload) {
        throw new Error('Method not implemented.');
    }
    _delegateToProvider(provider) {
        // Sorry for all the anys
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const delegate = (fn) => {
            if (typeof provider[fn] === 'function') {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                this[fn] = provider[fn].bind(provider);
            }
        };
        // If the subprovider is a ws or ipc provider, then register all its methods on this provider
        // and delegate calls to the subprovider. This allows subscriptions to work.
        delegate('eventNames');
        delegate('listeners');
        delegate('listenerCount');
        delegate('emit');
        delegate('on');
        delegate('addListener');
        delegate('once');
        delegate('removeListener');
        delegate('off');
        delegate('removeAllListeners');
        delegate('connect');
        delegate('reset');
        delegate('disconnect');
        delegate('supportsSubscriptions');
        delegate('reconnect');
    }
}
exports.DefenderRelaySenderProvider = DefenderRelaySenderProvider;
