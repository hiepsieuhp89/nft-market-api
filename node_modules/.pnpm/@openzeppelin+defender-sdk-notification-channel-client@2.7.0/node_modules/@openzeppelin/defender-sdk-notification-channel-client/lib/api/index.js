"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NotificationChannelClient = void 0;
const defender_sdk_base_client_1 = require("@openzeppelin/defender-sdk-base-client");
const crypto_1 = __importDefault(require("crypto"));
const utils_1 = require("./utils");
const PATH = '/notifications';
class NotificationChannelClient extends defender_sdk_base_client_1.BaseApiClient {
    getPoolId() {
        return process.env.DEFENDER_POOL_ID || 'us-west-2_94f3puJWv';
    }
    getPoolClientId() {
        return process.env.DEFENDER_POOL_CLIENT_ID || '40e58hbc7pktmnp9i26hh5nsav';
    }
    getApiUrl() {
        return process.env.DEFENDER_API_URL || 'https://defender-api.openzeppelin.com/v2/';
    }
    async create(notification) {
        return this.apiCall(async (api) => {
            return await api.post(`${PATH}/${notification.type}`, notification);
        });
    }
    async list() {
        return this.apiCall(async (api) => {
            return await api.get(`${PATH}`);
        });
    }
    async delete(id, type) {
        return this.apiCall(async (api) => {
            return await api.delete(`${PATH}/${type}/${id}`);
        });
    }
    async get(id, type) {
        return this.apiCall(async (api) => {
            return await api.get(`${PATH}/${type}/${id}`);
        });
    }
    async update(id, type, notification) {
        return this.apiCall(async (api) => {
            return await api.put(`${PATH}/${type}/${id}`, notification);
        });
    }
    verifySignature(params) {
        if (!params.body)
            throw new Error('Body payload is missing');
        if (!params.secret)
            throw new Error('Secret is missing');
        if (!params.signature)
            throw new Error('Signature is missing');
        if (!params.timestamp)
            throw new Error('Timestamp is missing');
        const TEN_MINUTES_IN_MS = 1000 * 60 * 10;
        const validityInMillis = params.validityInMs || TEN_MINUTES_IN_MS;
        // Check if the timestamp is valid
        const createdAt = new Date(params.timestamp);
        const millisSince = (0, utils_1.getMillisSince)(createdAt);
        const isExpired = millisSince >= validityInMillis || millisSince <= 0;
        if (isExpired)
            return { valid: false, error: 'Timestamp is expired' };
        const bodyObject = typeof params.body === 'string' ? JSON.parse(params.body) : params.body;
        try {
            // Verify the signature
            const payloadToVerify = JSON.stringify({ ...bodyObject, timestamp: params.timestamp });
            const generatedSignature = crypto_1.default.createHmac('sha256', params.secret).update(payloadToVerify).digest('hex');
            const signatureValid = generatedSignature === params.signature;
            const error = !signatureValid ? 'Signature is invalid' : undefined;
            return { valid: signatureValid, error };
        }
        catch (e) {
            return { valid: false, error: 'Error verifying signature' };
        }
    }
}
exports.NotificationChannelClient = NotificationChannelClient;
