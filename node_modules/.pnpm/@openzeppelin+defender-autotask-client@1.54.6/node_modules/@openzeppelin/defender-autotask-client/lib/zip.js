"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.zipFolder = exports.zipSources = void 0;
const jszip_1 = __importDefault(require("jszip"));
const glob_1 = __importDefault(require("glob"));
const util_1 = require("util");
const fs_1 = require("fs");
const fs_2 = require("fs");
const path_1 = require("path");
async function zipSources(sources) {
    if (!sources['index.js'])
        throw new Error(`Expected index.js entrypoint in sources`);
    const zip = new jszip_1.default();
    for (const source in sources) {
        zip.file(source, sources[source], { binary: false });
    }
    const zippedCode = await zip.generateAsync({ type: 'nodebuffer' });
    return zippedCode.toString('base64');
}
exports.zipSources = zipSources;
async function zipFolder(folderPath) {
    if (!(0, fs_2.existsSync)((0, path_1.join)(folderPath, 'index.js')))
        throw new Error(`Expected index.js entrypoint in folder`);
    const files = await (0, util_1.promisify)(glob_1.default)('**', { cwd: folderPath, nodir: true });
    const zip = new jszip_1.default();
    for (const path of files) {
        const content = await (0, util_1.promisify)(fs_1.readFile)((0, path_1.join)(folderPath, path));
        // We hardcode the date so we generate the same zip every time given the same contents
        // This allows us to use the codedigest to decide whether or not to reupload code
        zip.file(path, content, { date: new Date(2020, 1, 1, 0, 0, 0, 0) });
    }
    const zippedCode = await zip.generateAsync({ type: 'nodebuffer' });
    return zippedCode.toString('base64');
}
exports.zipFolder = zipFolder;
